//game canvas
import { useEffect, useRef, useState, forwardRef, useImperativeHandle } from "react";
import { Howl } from "howler";
import orbCollect from '@/assets/audio/orb-collect.mp3';
import guardianAlert from '@/assets/audio/guardian-alert.mp3';
import gameOver from '@/assets/audio/game-over.mp3';
import victory from '@/assets/audio/victory.mp3';
import backgroundMusic from '@/assets/audio/background-music.mp3';
import spriteSheet from '@/assets/sprites/player-sprite-sheet.png';
import leftImage from '@/assets/sprites/left.png';
import rightImage from '@/assets/sprites/right.png';
import guardSpriteSheet from '@/assets/sprites/guard-sprite-sheet.png';

// Configuration for game levels
const gameConfig = {
  MAX_LEVELS: 10,
  baseTimer: 10,
  timerIncrement: 2,
  baseGuardSpeed: 1.5,
  speedIncrement: 0.5,
  initialOrbs: 2,
  orbsPerLevel: 1,
  initialGuards: 1,
  guardsPerLevel: 1,
  safeDistance: 100,
  margin: 50,
};

interface GameCanvasProps {
  isActive: boolean;
  onGameStateChange: (state: 'playing' | 'paused' | 'gameOver' | 'victory') => void;
  memoriesCollected: number;
  onMemoryCollected: () => void;
  playerName: string;
  onPlayerNameLoaded: (name: string) => void;
  muted: boolean;
  onTimerUpdate?: (time: number) => void;
  onTimerActive?: (isActive: boolean) => void;
  onLevelChange?: (level: number) => void;
  // NEW: Prop for mobile controls
  mobileDirection?: { up: boolean; down: boolean; left: boolean; right: boolean };
}

interface Guardian {
  x: number;
  y: number;
  direction: number;
  patrol: { start: number; end: number };
  alert: boolean;
  patrolType: 'horizontal' | 'vertical';
}

interface SavedGameState {
  player: { x: number; y: number; size: number };
  memoryOrbs: { x: number; y: number; collected: boolean; pulse: number; collectingTime: number }[];
  guardians: Guardian[];
  memoriesCollected: number;
  playerName: string;
  currentLevel: number;
  timeRemaining: number;
}

export const GameCanvas = forwardRef<any, GameCanvasProps>(({
  isActive,
  onGameStateChange,
  memoriesCollected,
  onMemoryCollected,
  playerName,
  onPlayerNameLoaded,
  muted,
  onTimerUpdate,
  onTimerActive,
  onLevelChange,
  // NEW: Destructure mobileDirection with a default value
  mobileDirection = { up: false, down: false, left: false, right: false },
}, ref) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [gameState, setGameState] = useState<'idle' | 'playing'>('idle');
  const [currentLevel, setCurrentLevel] = useState(1);
  const [timeRemaining, setTimeRemaining] = useState(0);
  const [isLoading, setIsLoading] = useState(false);
  const [loadingMessage, setLoadingMessage] = useState('');
  const soundsRef = useRef<{
    orbCollect: Howl;
    guardianAlert: Howl;
    gameOver: Howl;
    victory: Howl;
    background: Howl;
  } | null>(null);
  const firstRender = useRef(true);
  const lastTimerUpdate = useRef<number>(Date.now());
  const timerStarted = useRef(false);
  const player = useRef({ x: 400, y: 300, size: 20 });
  const memoryOrbs = useRef<{ x: number; y: number; collected: boolean; pulse: number; collectingTime: number }[]>([]);
  const guardians = useRef<Guardian[]>([]);
  const previousMemoryCount = useRef(0);
  const alertedGuardians = useRef<Set<number>>(new Set());
  

  const getLevelConfig = (level: number) => ({
    orbs: gameConfig.initialOrbs + (level - 1) * gameConfig.orbsPerLevel,
    guards: gameConfig.initialGuards + (level - 1) * gameConfig.guardsPerLevel,
    guardSpeed: gameConfig.baseGuardSpeed + (level - 1) * gameConfig.speedIncrement,
    timer: gameConfig.baseTimer + (level - 1) * gameConfig.timerIncrement,
  });

  const getRandomPosition = (canvas: { width: number; height: number }) => ({
    x: gameConfig.margin + Math.random() * (canvas.width - 2 * gameConfig.margin),
    y: gameConfig.margin + Math.random() * (canvas.height - 2 * gameConfig.margin),
  });

  const isSafePosition = (pos1: { x: number; y: number }, pos2: { x: number; y: number }) => {
    const dx = pos1.x - pos2.x;
    const dy = pos1.y - pos2.y;
    return Math.sqrt(dx * dx + dy * dy) >= gameConfig.safeDistance;
  };

  useEffect(() => {
    soundsRef.current = {
      orbCollect: new Howl({ src: [orbCollect], volume: 0.5, onloaderror: (id, error) => console.error('Failed to load orb-collect.mp3:', error) }),
      guardianAlert: new Howl({ src: [guardianAlert], volume: 0.6, onloaderror: (id, error) => console.error('Failed to load guardian-alert.mp3:', error) }),
      gameOver: new Howl({ src: [gameOver], volume: 0.7, onloaderror: (id, error) => console.error('Failed to load game-over.mp3:', error) }),
      victory: new Howl({ src: [victory], volume: 0.7, onloaderror: (id, error) => console.error('Failed to load victory.mp3:', error) }),
      background: new Howl({ src: [backgroundMusic], loop: true, volume: 0.3, onloaderror: (id, error) => console.error('Failed to load background-music.mp3:', error) }),
    };

    return () => {
      if (soundsRef.current) Object.values(soundsRef.current).forEach(sound => sound.unload());
    };
  }, []);

  useEffect(() => {
    if (soundsRef.current) {
      if (!muted) {
        if (!soundsRef.current.background.playing()) {
          soundsRef.current.background.play();
        }
      } else {
        soundsRef.current.background.stop();
      }
    }
  }, [muted]);

  useEffect(() => {
    onPlayerNameLoaded(playerName || "Player");
  }, [onPlayerNameLoaded]);

  useEffect(() => {
    if (onLevelChange) onLevelChange(currentLevel);
  }, [currentLevel, onLevelChange]);

  useEffect(() => {
    if (onTimerUpdate) onTimerUpdate(timeRemaining);
    if (onTimerActive) onTimerActive(timerStarted.current && timeRemaining > 0);
  }, [timeRemaining, onTimerUpdate, onTimerActive]);
 

useEffect(() => {
  if (!timerStarted.current || !isActive || gameState !== 'playing') return;

  const intervalId = setInterval(() => {
    setTimeRemaining(prev => {
      const newTime = Math.max(0, prev - 1);
      if (newTime === 0) {
        const collected = memoryOrbs.current.filter(o => o.collected).length;
        if (collected < memoryOrbs.current.length) {
          timerStarted.current = false;
          saveGameState();
          onGameStateChange('gameOver');
          if (soundsRef.current && !muted) soundsRef.current.gameOver.play();
        }
      }
      return newTime;
    });
  }, 1000);

  return () => clearInterval(intervalId);
}, [isActive, gameState, muted]);


  const saveGameState = () => {
    const state: SavedGameState = {
      player: { ...player.current },
      memoryOrbs: memoryOrbs.current.map(orb => ({ ...orb })),
      guardians: guardians.current.map(guard => ({ ...guard })),
      memoriesCollected: memoryOrbs.current.filter(orb => orb.collected).length,
      playerName,
      currentLevel,
      timeRemaining,
    };
    localStorage.setItem('gameState', JSON.stringify(state));
  };

  const resetGameState = (level: number = 1) => {
    console.log(`Resetting to level ${level}`);
    firstRender.current = true;
    const config = getLevelConfig(level);
    const canvas = { width: 800, height: 600 }; // Keep internal resolution fixed

    player.current = { x: 400, y: 300, size: 20 };
    const newOrbs: { x: number; y: number; collected: boolean; pulse: number; collectingTime: number }[] = [];
    const newGuardians: Guardian[] = [];

    for (let i = 0; i < config.orbs; i++) {
      let attempts = 0;
      let newOrb;
      do {
        newOrb = {
          ...getRandomPosition(canvas),
          collected: false,
          pulse: Math.random() * Math.PI * 2,
          collectingTime: 0,
        };
        attempts++;
      } while (
        attempts < 50 && (
          newOrbs.some(orb => !isSafePosition(newOrb, orb)) ||
          !isSafePosition(newOrb, player.current)
        )
      );
      if (attempts < 50) {
        newOrbs.push(newOrb);
      } else {
        newOrbs.push({
          x: gameConfig.margin + i * 100,
          y: gameConfig.margin + 100,
          collected: false,
          pulse: 0,
          collectingTime: 0,
        });
      }
    }

    for (let i = 0; i < config.guards; i++) {
      let attempts = 0;
      let newGuard;
      do {
        const pos = getRandomPosition(canvas);
        const isHorizontal = i % 2 === 0;
        newGuard = {
          x: pos.x,
          y: pos.y,
          direction: Math.random() > 0.5 ? 1 : -1,
          patrol: isHorizontal
            ? { start: gameConfig.margin, end: canvas.width - gameConfig.margin }
            : { start: gameConfig.margin, end: canvas.height - gameConfig.margin },
          alert: false,
          patrolType: isHorizontal ? 'horizontal' : 'vertical',
        };
        attempts++;
      } while (
        attempts < 50 && (
          newGuardians.some(guard => !isSafePosition(newGuard, guard)) ||
          newOrbs.some(orb => !isSafePosition(newGuard, orb)) ||
          !isSafePosition(newGuard, player.current)
        )
      );
      if (attempts < 50) {
        newGuardians.push(newGuard);
      } else {
        newGuardians.push({
          x: gameConfig.margin + (i + 1) * 100,
          y: canvas.height - gameConfig.margin - 100,
          direction: 1,
          patrol: { start: gameConfig.margin, end: canvas.width - gameConfig.margin },
          alert: false,
          patrolType: 'horizontal',
        });
      }
    }

    memoryOrbs.current = newOrbs;
    guardians.current = newGuardians;
    previousMemoryCount.current = 0;
    alertedGuardians.current.clear();
    
    timerStarted.current = true;
    lastTimerUpdate.current = Date.now();
    setTimeRemaining(config.timer);
    setCurrentLevel(level);
    setGameState('playing');
    setIsLoading(false);
    onGameStateChange('playing');
    saveGameState();
  };

  useImperativeHandle(ref, () => ({ reset: () => resetGameState(1) }));

  useEffect(() => {
    if (!canvasRef.current) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Set fixed internal resolution, CSS will handle scaling
    canvas.width = 800;
    canvas.height = 600;

    let animationId: number;
    let roomShift = { x: 0, y: 0, intensity: 0 };
    const keys: { [key: string]: boolean } = {};

    const spriteImage = new Image();
    spriteImage.src = spriteSheet;
    const guardImage = new Image();
    guardImage.src = guardSpriteSheet;
    const leftImg = new Image();
    leftImg.src = leftImage;
    const rightImg = new Image();
    rightImg.src = rightImage;

    const handleKeyDown = (e: KeyboardEvent) => {
      keys[e.key.toLowerCase()] = true;
      if (e.key === 'Escape') onGameStateChange('paused');
      if (e.key.toLowerCase() === 'r') resetGameState(currentLevel);
    };

    const handleKeyUp = (e: KeyboardEvent) => {
      keys[e.key.toLowerCase()] = false;
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    const render = () => {
      if (!ctx || !isActive || isLoading) {
        if (animationId) cancelAnimationFrame(animationId);
        return;
      }

      const orbs = memoryOrbs.current;
      const guards = guardians.current;
      const config = getLevelConfig(currentLevel);

      const currentMemoryCount = orbs.filter(orb => orb.collected).length;
      if (currentMemoryCount > previousMemoryCount.current) {
        roomShift.intensity = 0.5;
        previousMemoryCount.current = currentMemoryCount;
        
        timerStarted.current = true;
        guards.forEach(g => { g.alert = false; });
        alertedGuardians.current.clear();
        if (soundsRef.current && !muted) soundsRef.current.orbCollect.play();
        onMemoryCollected();
        saveGameState();
      }

      if (roomShift.intensity > 0) {
        roomShift.intensity -= 0.03;
        roomShift.x = (Math.random() - 0.5) * roomShift.intensity * 10;
        roomShift.y = (Math.random() - 0.5) * roomShift.intensity * 10;
      }

      ctx.save();
      ctx.translate(roomShift.x, roomShift.y);

      // ... (Drawing logic for background and border remains the same) ...
      const gradient = ctx.createLinearGradient(0, 0, 800, 600);
      gradient.addColorStop(0, 'hsl(225, 25%, 8%)');
      gradient.addColorStop(0.5, 'hsl(270, 40%, 15%)');
      gradient.addColorStop(1, 'hsl(280, 30%, 20%)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 800, 600);

      ctx.strokeStyle = 'hsl(280, 50%, 40%)';
      ctx.lineWidth = 3;
      ctx.setLineDash([10, 5]);
      ctx.strokeRect(10, 10, 780, 580);
      ctx.setLineDash([]);

      // ... (Drawing logic for orbs and guardians remains the same) ...
      orbs.forEach(orb => {
        if (orb.collected) return;
        orb.pulse += 0.05;
        const dx = player.current.x - orb.x;
        const dy = player.current.y - orb.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < player.current.size + 15 && orb.collectingTime === 0) {
          orb.collectingTime = 0.01;
          orb.collected = true;
        }
        if (orb.collectingTime > 0) {
          orb.collectingTime += 0.03;
          if (orb.collectingTime >= 1) {
            orb.collected = true;
          }
        }
        const glowSize = 15 + Math.sin(orb.pulse) * 5;
        const alpha = orb.collectingTime > 0 ? 1 - orb.collectingTime : 1;
        ctx.save();
        ctx.globalAlpha = alpha;
        const orbGradient = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, glowSize);
        orbGradient.addColorStop(0, 'hsl(280, 80%, 75%)');
        orbGradient.addColorStop(0.7, 'hsl(270, 70%, 65%)');
        orbGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = orbGradient;
        ctx.beginPath();
        ctx.arc(orb.x, orb.y, glowSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });

      guards.forEach((guardian, index) => {
        const dxToPlayer = player.current.x - guardian.x;
        const dyToPlayer = player.current.y - guardian.y;
        const distanceToPlayer = Math.sqrt(dxToPlayer * dxToPlayer + dyToPlayer * dyToPlayer);
        const isPlayerInRange = distanceToPlayer < 60 && !firstRender.current;
        if (isPlayerInRange && !guardian.alert) {
          guardian.alert = true;
          alertedGuardians.current.add(index);
          if (soundsRef.current && !muted) soundsRef.current.guardianAlert.play();
        }
        const baseSpeed = guardian.alert ? 2 : config.guardSpeed;
        const speed = baseSpeed + currentMemoryCount * 0.3;
        if (guardian.alert && distanceToPlayer > 5) {
          guardian.x += (dxToPlayer / distanceToPlayer) * speed;
          guardian.y += (dyToPlayer / distanceToPlayer) * speed;
        } else if (!guardian.alert) {
          if (guardian.patrolType === 'horizontal') {
            guardian.x += guardian.direction * speed;
            if (guardian.x >= guardian.patrol.end || guardian.x <= guardian.patrol.start) {
              guardian.direction *= -1;
              guardian.x = Math.max(guardian.patrol.start, Math.min(guardian.patrol.end, guardian.x));
            }
          } else {
            guardian.y += guardian.direction * speed;
            if (guardian.y >= guardian.patrol.end || guardian.y <= guardian.patrol.start) {
              guardian.direction *= -1;
              guardian.y = Math.max(guardian.patrol.start, Math.min(guardian.patrol.end, guardian.y));
            }
          }
        }
        if (guardian.alert) {
          ctx.save();
          ctx.strokeStyle = 'red';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(guardian.x, guardian.y, 30, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
        if (guardImage.complete) {
          ctx.drawImage(guardImage, guardian.x - 32, guardian.y - 32, 64, 64);
        } else {
          ctx.fillStyle = guardian.alert ? 'red' : 'orange';
          ctx.fillRect(guardian.x - 15, guardian.y - 15, 30, 30);
        }
        if (distanceToPlayer < 25 && !firstRender.current) {
          saveGameState();
          onGameStateChange('gameOver');
          if (soundsRef.current && !muted) soundsRef.current.gameOver.play();
          return;
        }
      });


      // MODIFIED: Player movement now checks mobileDirection prop
      const speed = 3;
      let direction = 'idle';
      if (keys['w'] || keys['arrowup'] || mobileDirection.up) {
        player.current.y = Math.max(20 + player.current.size, player.current.y - speed);
        direction = 'up';
      }
      if (keys['s'] || keys['arrowdown'] || mobileDirection.down) {
        player.current.y = Math.min(580 - player.current.size, player.current.y + speed);
        direction = 'down';
      }
      if (keys['a'] || keys['arrowleft'] || mobileDirection.left) {
        player.current.x = Math.max(20 + player.current.size, player.current.x - speed);
        direction = 'left';
      }
      if (keys['d'] || keys['arrowright'] || mobileDirection.right) {
        player.current.x = Math.min(780 - player.current.size, player.current.x + speed);
        direction = 'right';
      }

      // Render player
      if (direction === 'left' && leftImg.complete) {
        ctx.drawImage(leftImg, player.current.x - 32, player.current.y - 32, 64, 64);
      } else if (direction === 'right' && rightImg.complete) {
        ctx.drawImage(rightImg, player.current.x - 32, player.current.y - 32, 64, 64);
      } else if (spriteImage.complete) {
        ctx.drawImage(spriteImage, player.current.x - 32, player.current.y - 32, 64, 64);
      } else {
        ctx.fillStyle = 'blue';
        ctx.beginPath();
        ctx.arc(player.current.x, player.current.y, player.current.size, 0, Math.PI * 2);
        ctx.fill();
      }

      // ... (Timer, victory, and other logic remains the same) ...
      if (timerStarted.current && timeRemaining > 0) {
        const now = Date.now();
        const deltaTime = (now - lastTimerUpdate.current) / 1000;
        lastTimerUpdate.current = now;
        const newTime = Math.max(0, timeRemaining - deltaTime);
        if (Math.floor(newTime) !== Math.floor(timeRemaining)) {
          setTimeRemaining(newTime);
        }
        if (newTime <= 0) {
          const collected = memoryOrbs.current.filter(o => o.collected).length;
          if (collected < memoryOrbs.current.length) {
            saveGameState();
            onGameStateChange('gameOver');
            if (soundsRef.current && !muted) soundsRef.current.gameOver.play();
            return;
          }
        }
      }
      if (currentMemoryCount === orbs.length && orbs.length > 0) {
        if (currentLevel < gameConfig.MAX_LEVELS) {
          setIsLoading(true);
          setLoadingMessage(`Level ${currentLevel + 1}`);
          setTimeout(() => {
            setIsLoading(false);
            resetGameState(currentLevel + 1);
          }, 2000);
        } else {
          saveGameState();
          onGameStateChange('victory');
          if (soundsRef.current && !muted) soundsRef.current.victory.play();
        }
        return;
      }
      if (firstRender.current) firstRender.current = false;
      ctx.restore();
      animationId = requestAnimationFrame(render);
    };

    if (isActive) {
      if (gameState === 'idle') {
        resetGameState(1);
      }
      render();
    }

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      if (animationId) cancelAnimationFrame(animationId);
    };
  }, [isActive, onGameStateChange, onMemoryCollected, playerName, muted, currentLevel, mobileDirection]);

  return (
    <div className="w-full h-full flex justify-center items-center relative">
      <canvas
        ref={canvasRef}
        // MODIFIED: Canvas scales via CSS, internal resolution is fixed
        className="w-full h-full border-2 border-primary/30 rounded-lg shadow-2xl shadow-primary/20 bg-card"
        style={{ imageRendering: 'pixelated' }}
      />
      {isLoading && (
        <div className="absolute inset-0 bg-background/90 backdrop-blur-md flex items-center justify-center z-50">
          <div className="text-center space-y-4">
            <h2 className="font-dream text-4xl font-bold text-primary animate-pulse-glow">
              {loadingMessage}
            </h2>
            <p className="text-lg text-foreground">Preparing the Memory Palace...</p>
            <div className="loader animate-spin rounded-full h-12 w-12 border-t-4 border-primary mx-auto" />
          </div>
        </div>
      )}
    </div>
  );
});

GameCanvas.displayName = 'GameCanvas';